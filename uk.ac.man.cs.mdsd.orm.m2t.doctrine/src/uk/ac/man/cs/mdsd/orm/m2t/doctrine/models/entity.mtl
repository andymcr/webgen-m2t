[comment encoding = UTF-8 /]
[module entity(
	'http://www.cs.man.ac.uk/mdsd/2013/Criteria',
	'http://www.cs.man.ac.uk/mdsd/2010/ObjectRelationalMapping')]
[import uk::ac::man::cs::mdsd::criteria::m2t::criteria/]
[import uk::ac::man::cs::mdsd::orm::m2t::doctrine::criteria/]
[import uk::ac::man::cs::mdsd::orm::m2t::doctrine::names/]
[import uk::ac::man::cs::mdsd::orm::m2t::doctrine::files/]
[import uk::ac::man::cs::mdsd::orm::m2t::core::featureProperties/]

[template public model(entity : Entity)]
[file(entity.modelFilename(), false)]
<?php
namespace [entity.modelsNamespace()/];

use Doctrine\ORM\Mapping as ORM;
[if (entity.hasCollectionAssociations())]
use Doctrine\Common\Collections\ArrayCollection;
[/if]
[if (entity.hasValidatedFeatures())]
use Symfony\Component\Validator\Constraints as Assert;
[/if]

/**
 * @ORM\Entity
 * @ORM\Table(name="[entity.tableName/]")
 **/
class [entity.modelClassName()/]
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     **/
    protected $[entity.autoKeyName/];

[for (feature : Feature | entity.features)]
	[comment TODO sortout location features /]
	[if (not feature.isLocation())]
    /**
      [feature.ormAnnotation()/]
[if (feature.isValidated())]
      [feature.validationAnnotation()/]
[/if]
    **/
    protected $[feature.modelPropertyName()/];

	[/if]
[/for]
[if (entity.hasDefaultValueFeatures() or entity.hasCollectionAssociations())]
    [entity.constructor()/]

[/if]
    public function getId()
    {
        return $id;
    }

[for (feature : Feature | entity.features)]
    [feature.featureMethods()/]

[/for]
[for (label : ModelLabel | entity.displayLabels)]
    [label.modelLabel()/]

[/for]
[for (feature : SingletonResource | entity.resourceAttributes())]
	private function _save_[feature.modelPropertyName()/]()
	{
		$validation = Validation::factory($_FILES);
		$validation
			->rules('[feature.modelPropertyName()/]', array(
[if (feature.isRequired())]
				array('not_empty'),
				array('Upload::not_empty'),
[/if]
				array('Upload::valid'),
				array('Upload::size', array(':value', [comment resource.maximumUploadSize/])),
[comment if (resource.validUploadExtensions->notEmpty())/]
				array('Upload::type', array(':value', array([comment for (extension : String | resource.validUploadExtensions) separator(', ')/]'[comment extension/]'[comment /for/]))),
[comment /if/]
			));
		if ($validation->check() === FALSE)
			throw new ORM_Validation_Exception($this->errors_filename(), $validation);

		if ($_FILES['['/]'[feature.modelPropertyName()/]'[']'/]['['/]'error'[']'/] === UPLOAD_ERR_NO_FILE)
			return;

		if (!empty($this->[comment resource.columnName/])) 
			$filename = str_replace(' ', '_', pathinfo($this->[comment resource.columnName/], PATHINFO_FILENAME));
		else
			$filename = str_replace(' ', '_', pathinfo($_FILES['['/]'[feature.modelPropertyName()/]'[']'/]['['/]'name'[']'/], PATHINFO_FILENAME));
		$extension = pathinfo($_FILES['['/]'[feature.modelPropertyName()/]'[']'/]['['/]'name'[']'/], PATHINFO_EXTENSION);
[comment if (resource.uploadsWithinWebsite = true) /]
		$filepath = Upload::save($_FILES['['/]'[feature.modelPropertyName()/]'[']'/], $filename . '.' . $extension, DOCROOT . '[comment resource.relativeUploadDirectory/]');
		$this->[comment feature.columnName()/] = '[comment resource.relativeUploadDirectory/]/' . $filename . '.' . $extension;
[comment else/]
		$filepath = Upload::save($_FILES['['/]'[feature.modelPropertyName()/]'[']'/], $filename . '.' . $extension, 'c:\websites\files');
[comment /if/]
	}

[/for]
[if (entity.hasResourceAttributes())]
/*	public function save(Validation $validation = NULL)
	{
[for (feature : SingletonResource | entity.resourceAttributes())]
		$this->_save_[feature.modelPropertyName()/]();
[/for]
		parent::save($validation);
	}
*/
[/if]
}
[/file]
[/template]

[template private ormAnnotation(feature : Feature) post(trim())]
[if (feature.oclIsKindOf(EntityAttribute))]
* @ORM\Column(type="[feature.oclAsType(EntityAttribute).ormType/]")
[elseif (feature.oclIsKindOf(EntityAssociation))]
[let association : EntityAssociation = feature.oclAsType(EntityAssociation)]
	[if (association.oclIsTypeOf(SingletonAssociation))]
	[let singleton : SingletonAssociation = association.oclAsType(SingletonAssociation)]
* @ORM\[singleton.associationRelationship/](targetEntity="[association.modelName()/]"[if (singleton.owningEnd <> true)], mappedBy="[association.opposite.modelPropertyName()/]"[/if])
		[if (singleton.owningEnd = true)]
* @ORM\JoinColumn(name="[association.columnName/]", referencedColumnName="[association.opposite.partOf.oclAsType(Entity).autoKeyName/]")
		[/if]
	[/let]
	[else]
	[let collection : CollectionAssociation = association.oclAsType(CollectionAssociation)]
* @ORM\[collection.associationRelationship/](targetEntity="[association.modelName()/]"[if (collection.associationRelationship = CollectionAssociationRelationships::OneToMany)], mappedBy="[association.opposite.modelPropertyName()/]"[/if])
		[if (association.owningEnd)]
* @ORM\JoinTable(name="[association.pivotTableName/]",
    joinColumns={@ORM\JoinColumn(name="[association.opposite.columnName/]")},
    inverseJoinColumns={@ORM\JoinColumn(name="[feature.columnName/]")})
		[/if]
	[/let]
	[/if]
[/let]
[/if]
[/template]

[template private validationAnnotation(feature : Feature) post(trim())]
		[if (feature.isValidated())]
			[if (feature.isRequired())]
	 * @Assert\NotBlank
			[/if]
		[/if]
[/template]

[template private constructor(entity : Entity)]
public function __construct()
{
[for (feature : Feature | entity.features)]
	[if (feature.hasDefaultValue())]
	$this->[feature.modelPropertyName()/] = [feature.oclAsType(SingletonAttribute).defaultValue.valueExpression()/];
	[/if]
	[if (feature.oclIsTypeOf(CollectionAssociation))]
		[if (feature.oclAsType(CollectionAssociation).owningEnd)]
	$this->[feature.modelPropertyName()/] = new ArrayCollection();
		[/if]
	[/if]
[/for]
}
[/template]

[template private featureMethods(feature : Feature) post(trim())]
public function [if (feature.isBooleanDataType())]is[else]get[/if][feature.modelPropertyName().toUpperFirst()/]()
{
    return $this->[feature.modelPropertyName()/];
}

[if (feature.isSingleton())]
public function set[feature.modelPropertyName().toUpperFirst()/]($[feature.instanceName()/]) {
//				array('trim'),
	[if (feature.oclIsKindOf(SingletonAttribute))]
	[let attribute : SingletonAttribute = feature.oclAsType(SingletonAttribute)]
		[if (attribute.oclIsTypeOf(SingletonElement))]
		[let element : SingletonElement = attribute.oclAsType(SingletonElement)]
			[if (element.caseInsensitive)]
    $this->[element.modelPropertyName()/] = strtolower(trim($[element.instanceName()/]));
			[elseif (element.encrypt)]
//				array(array(Auth::instance(), 'hash_password_and_salt'), array(':value', ':model')),
			[else]
    $this->[element.modelPropertyName()/] = trim($[element.instanceName()/]);
			[/if]
		[/let]
		[elseif (attribute.oclIsTypeOf(SingletonDate))]
    if (trim($[attribute.instanceName()/]) == FALSE) {
        $this->[attribute.modelPropertyName()/] = NULL;
    } else {
    }
		[/if]
	[/let]
	[/if]
}

	[else]
public function add[feature.modelPropertyName().toUpperFirst()/]($[feature.modelPropertyName()/])
{
}

[/if]
[/template]

[template private modelLabel(label : ModelLabel)]
public function get[label.name.toUpperFirst()/][if (not label.name.endsWith('Label'))]Label[/if]()
{
        return sprintf('[label.format/]', [for (feature : ModelLabelFeature | label.features) separator(', ')]
$this->[if (feature.oclIsTypeOf(ModelLabelAttribute))]
[feature.oclAsType(ModelLabelAttribute).attribute.modelPropertyName()/][else]
[let association : ModelLabelAssociation = feature.oclAsType(ModelLabelAssociation)]
[association.association.modelPropertyName()/]->get[if (association.dynamicLabel.oclIsUndefined())]Default[else][association.dynamicLabel.name.toUpperFirst()/][/if]Label()[/let]
[/if][/for]);
}
[/template]